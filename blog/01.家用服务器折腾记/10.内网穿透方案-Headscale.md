---
title: 内网穿透方案-Headscale
date: 2022-08-08 00:37:45
permalink: /pages/cacef3/
categories: 
  - 环境管理
  - 家用服务器折腾记

---

上文已介绍了zerotier是异地组网工具，下面再介绍一款开源的内网穿透工具Headscale，它是基于Tailscale的开源版本。

<!--more-->
<!-- truncate -->

## 介绍

> Tailscale 是一种基于 WireGuard 的虚拟组网工具，和 Netmaker 类似，**最大的区别在于 Tailscale 是在用户态实现了 WireGuard 协议，而 Netmaker 直接使用了内核态的 WireGuard**。所以 Tailscale 相比于内核态 WireGuard 性能会有所损失，但与 OpenVPN 之流相比还是能甩好几十条街的，Tailscale 虽然在性能上做了些许取舍，但在功能和易用性上绝对是完爆其他工具
>
> --详见 [Tailscale 基础教程：Headscale 的部署方法和使用教程](https://icloudnative.io/posts/how-to-set-up-or-migrate-headscale/#macos)

## 服务端部署

### Headscale 配置

```yaml
# docker network create [OPTIONS] NETWORK
# docker network create --ipv6 caddy_net
version: '3.5'
services:
  headscale:
    image: headscale/headscale:latest
    container_name: headscale
    volumes:
      - ./config:/etc/headscale
      - ../../docker-data/headscale:/var/lib/headscale
    cap_add:
      - NET_ADMIN
      - NET_RAW
      - SYS_MODULE
    sysctls:
      - net.ipv4.ip_forward=1
      - net.ipv6.conf.all.forwarding=1
    # proxy by caddy
    # ports:
    #   - 3050:8080
    networks:
      - caddy_net
    command: ["headscale", "serve"]
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "50m"


  headscale-ui:
    image: ghcr.io/gurucomputing/headscale-ui:latest
    container_name: headscale-ui
    # proxy by caddy
    # ports:
    #   - 3100:80
    networks:
      - caddy_net
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "50m"

networks:
  caddy_net:
    name: caddy_net
    external: true
```

一些注意事项：

- 网上给出了好几种部署方式，一般分为容器化部署和非容器化部署。需要注意的是如果是使用容器化部署，需要将
- 为什么注释掉端口映射？建议刚开始部署服务的同学打开端口映射，这样方便在容器外调试。我关闭是因为想要通过Caddy来代理。（话说我也是从这个服务里了解Caddy的）。
  - Caddy 是Web服务器，是Nginx的替代品，配置上比Nginx简单很多。特点是自动帮助申请Https，省去了自己配置证书的麻烦。与之相类似的服务有[NginxProxyManager](https://github.com/NginxProxyManager/nginx-proxy-manager)。
  - 新建了一个容器网络 `caddy_net`，所有服务与`caddy_net`联通，这样就可以保证端口不暴露出去，所有的请求都经过Caddy。
- headscale-ui
  headscale-ui 是一款开源的Headscale图形化配置页面，用以添加客户端设备。这里坑的地方在于headscale-ui是有跨域限制。举例Headscale部署在 abc.com上，Headscale-ui 必须部署在 abc.com/web 上，不然就会出现错误。

### Config配置

如下文件约定了Headscale的基础配置，容器中唯一需要注意的是，如果对外提供服务必须将 `127.0.0.1` 改为 `0.0.0.0` 这样保证了外部网络的请求能被处理。

```yaml
# reference: https://github.com/juanfont/headscale/raw/main/config-example.yaml
---
# headscale will look for a configuration file named `config.yaml` (or `config.json`) in the following order:
#
# - `/etc/headscale`
# - `~/.headscale`
# - current working directory

# The url clients will connect to.
# Typically this will be a domain like:
#
# https://myheadscale.example.com:443
#
# 客户端真实请求的地址，反向代理后的地址
# 公网IP，或是域名，是所有设备需要能访问到的地址。
server_url: https://xxx.com/

# Address to listen to / bind to on the server
#
# For local:
# listen_addr: 127.0.0.1:8080
# For production:
# Listen to 0.0.0.0 so it's accessible outside the container
listen_addr: 0.0.0.0:8080

# Address to listen to /metrics, you may want
# to keep this endpoint private to your internal
# network
# For local:
# metrics_listen_addr: 127.0.0.1:9090
# set to 0.0.0
# Listen to 0.0.0.0 so it's accessible outside the container
metrics_listen_addr: 0.0.0.0:9090

# Address to listen for gRPC.
# gRPC is used for controlling a headscale server
# remotely with the CLI
# Note: Remote access _only_ works if you have
# valid certificates.
#
# For production:
# grpc_listen_addr: 0.0.0.0:50443
grpc_listen_addr: 127.0.0.1:50443

# Allow the gRPC admin interface to run in INSECURE
# mode. This is not recommended as the traffic will
# be unencrypted. Only enable if you know what you
# are doing.
grpc_allow_insecure: false

# Private key used to encrypt the traffic between headscale
# and Tailscale clients.
# The private key file will be autogenerated if it's missing.
#
# For production:
# /var/lib/headscale/private.key
# For test:
# ./private.key
private_key_path: /var/lib/headscale/private.key

# The Noise section includes specific configuration for the
# TS2021 Noise protocol
noise:
  # The Noise private key is used to encrypt the
  # traffic between headscale and Tailscale clients when
  # using the new Noise-based protocol. It must be different
  # from the legacy private key.
  #
  # For production:
  # private_key_path: /var/lib/headscale/noise_private.key
  # For test:
  # ./noise_private.key
  private_key_path: /var/lib/headscale/noise_private.key

# List of IP prefixes to allocate tailaddresses from.
# Each prefix consists of either an IPv4 or IPv6 address,
# and the associated prefix length, delimited by a slash.
# While this looks like it can take arbitrary values, it
# needs to be within IP ranges supported by the Tailscale
# client.
# IPv6: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#LL81C52-L81C71
# IPv4: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#L33
ip_prefixes:
  - fd7a:115c:a1e0::/48
  - 100.64.0.0/10

# DERP is a relay system that Tailscale uses when a direct
# connection cannot be established.
# https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp
#
# headscale needs a list of DERP servers that can be presented
# to the clients.
derp:
  server:
    # If enabled, runs the embedded DERP server and merges it into the rest of the DERP config
    # The Headscale server_url defined above MUST be using https, DERP requires TLS to be in place
    enabled: false

    # Region ID to use for the embedded DERP server.
    # The local DERP prevails if the region ID collides with other region ID coming from
    # the regular DERP config.
    region_id: 999

    # Region code and name are displayed in the Tailscale UI to identify a DERP region
    region_code: "headscale"
    region_name: "Headscale Embedded DERP"

    # Listens over UDP at the configured address for STUN connections - to help with NAT traversal.
    # When the embedded DERP server is enabled stun_listen_addr MUST be defined.
    #
    # For more details on how this works, check this great article: https://tailscale.com/blog/how-tailscale-works/
    stun_listen_addr: "0.0.0.0:3478"

  # List of externally available DERP maps encoded in JSON
  urls:
    - https://controlplane.tailscale.com/derpmap/default

  # Locally available DERP map files encoded in YAML
  #
  # This option is mostly interesting for people hosting
  # their own DERP servers:
  # https://tailscale.com/kb/1118/custom-derp-servers/
  #
  # paths:
  #   - /etc/headscale/derp-example.yaml
  paths: []

  # If enabled, a worker will be set up to periodically
  # refresh the given sources and update the derpmap
  # will be set up.
  auto_update_enabled: true

  # How often should we check for DERP updates?
  update_frequency: 24h

# Disables the automatic check for headscale updates on startup
disable_check_updates: false

# Time before an inactive ephemeral node is deleted?
ephemeral_node_inactivity_timeout: 30m

# Period to check for node updates within the tailnet. A value too low will severely affect
# CPU consumption of Headscale. A value too high (over 60s) will cause problems
# for the nodes, as they won't get updates or keep alive messages frequently enough.
# In case of doubts, do not touch the default 10s.
node_update_check_interval: 10s

# SQLite config
db_type: sqlite3

# For production:
# db_path: /var/lib/headscale/db.sqlite
db_path: ./db.sqlite

# # Postgres config
# If using a Unix socket to connect to Postgres, set the socket path in the 'host' field and leave 'port' blank.
# db_type: postgres
# db_host: localhost
# db_port: 5432
# db_name: headscale
# db_user: foo
# db_pass: bar

# If other 'sslmode' is required instead of 'require(true)' and 'disabled(false)', set the 'sslmode' you need
# in the 'db_ssl' field. Refers to https://www.postgresql.org/docs/current/libpq-ssl.html Table 34.1.
# db_ssl: false

### TLS configuration
#
## Let's encrypt / ACME
#
# headscale supports automatically requesting and setting up
# TLS for a domain with Let's Encrypt.
#
# URL to ACME directory
acme_url: https://acme-v02.api.letsencrypt.org/directory

# Email to register with ACME provider
acme_email: ""

# Domain name to request a TLS certificate for:
tls_letsencrypt_hostname: ""

# Path to store certificates and metadata needed by
# letsencrypt
# For production:
# tls_letsencrypt_cache_dir: /var/lib/headscale/cache
# For test:
# ./cache
tls_letsencrypt_cache_dir: /var/lib/headscale/cache

# Type of ACME challenge to use, currently supported types:
# HTTP-01 or TLS-ALPN-01
# See [docs/tls.md](docs/tls.md) for more information
tls_letsencrypt_challenge_type: HTTP-01
# When HTTP-01 challenge is chosen, letsencrypt must set up a
# verification endpoint, and it will be listening on:
# :http = port 80
tls_letsencrypt_listen: ":http"

## Use already defined certificates:
tls_cert_path: ""
tls_key_path: ""

log:
  # Output formatting for logs: text or json
  format: text
  level: info

# Path to a file containg ACL policies.
# ACLs can be defined as YAML or HUJSON.
# https://tailscale.com/kb/1018/acls/
acl_policy_path: ""

## DNS
#
# headscale supports Tailscale's DNS configuration and MagicDNS.
# Please have a look to their KB to better understand the concepts:
#
# - https://tailscale.com/kb/1054/dns/
# - https://tailscale.com/kb/1081/magicdns/
# - https://tailscale.com/blog/2021-09-private-dns-with-magicdns/
#
dns_config:
  # Whether to prefer using Headscale provided DNS or use local.
  override_local_dns: true

  # List of DNS servers to expose to clients.
  nameservers:
    - 1.1.1.1

  # NextDNS (see https://tailscale.com/kb/1218/nextdns/).
  # "abc123" is example NextDNS ID, replace with yours.
  #
  # With metadata sharing:
  # nameservers:
  #   - https://dns.nextdns.io/abc123
  #
  # Without metadata sharing:
  # nameservers:
  #   - 2a07:a8c0::ab:c123
  #   - 2a07:a8c1::ab:c123

  # Split DNS (see https://tailscale.com/kb/1054/dns/),
  # list of search domains and the DNS to query for each one.
  #
  # restricted_nameservers:
  #   foo.bar.com:
  #     - 1.1.1.1
  #   darp.headscale.net:
  #     - 1.1.1.1
  #     - 8.8.8.8

  # Search domains to inject.
  domains: []

  # Extra DNS records
  # so far only A-records are supported (on the tailscale side)
  # See https://github.com/juanfont/headscale/blob/main/docs/dns-records.md#Limitations
  # extra_records:
  #   - name: "grafana.myvpn.example.com"
  #     type: "A"
  #     value: "100.64.0.3"
  #
  #   # you can also put it in one line
  #   - { name: "prometheus.myvpn.example.com", type: "A", value: "100.64.0.3" }

  # Whether to use [MagicDNS](https://tailscale.com/kb/1081/magicdns/).
  # Only works if there is at least a nameserver defined.
  # 但是Tailscale有一个很坏的缺点，就是它不能自定义节点的IP，控制器给分配什么就只能是什么
  # 所以你肯定会需要Magic DNS来帮你辨识节点的！
  magic_dns: true

  # Defines the base domain to create the hostnames for MagicDNS.
  # `base_domain` must be a FQDNs, without the trailing dot.
  # The FQDN of the hosts will be
  # `hostname.user.base_domain` (e.g., _myhost.myuser.example.com_).
  # 显示在Magic DNS里的设备域名，随便写写
  base_domain: example.com

# Unix socket used for the CLI to connect without authentication
# Note: for production you will want to set this to something like:
# For production
# unix_socket: /var/run/headscale.sock
# For test
# unix_socket: ./headscale.sock
unix_socket: /var/run/headscale.sock
unix_socket_permission: "0770"
#
# headscale supports experimental OpenID connect support,
# it is still being tested and might have some bugs, please
# help us test it.
# OpenID Connect
# oidc:
#   only_start_if_oidc_is_available: true
#   issuer: "https://your-oidc.issuer.com/path"
#   client_id: "your-oidc-client-id"
#   client_secret: "your-oidc-client-secret"
#   # Alternatively, set `client_secret_path` to read the secret from the file.
#   # It resolves environment variables, making integration to systemd's
#   # `LoadCredential` straightforward:
#   client_secret_path: "${CREDENTIALS_DIRECTORY}/oidc_client_secret"
#   # client_secret and client_secret_path are mutually exclusive.
#
#   # The amount of time from a node is authenticated with OpenID until it
#   # expires and needs to reauthenticate.
#   # Setting the value to "0" will mean no expiry.
#   expiry: 180d
#
#   # Use the expiry from the token received from OpenID when the user logged
#   # in, this will typically lead to frequent need to reauthenticate and should
#   # only been enabled if you know what you are doing.
#   # Note: enabling this will cause `oidc.expiry` to be ignored.
#   use_expiry_from_token: false
#
#   # Customize the scopes used in the OIDC flow, defaults to "openid", "profile" and "email" and add custom query
#   # parameters to the Authorize Endpoint request. Scopes default to "openid", "profile" and "email".
#
#   scope: ["openid", "profile", "email", "custom"]
#   extra_params:
#     domain_hint: example.com
#
#   # List allowed principal domains and/or users. If an authenticated user's domain is not in this list, the
#   # authentication request will be rejected.
#
#   allowed_domains:
#     - example.com
#   # Note: Groups from keycloak have a leading '/'
#   allowed_groups:
#     - /headscale
#   allowed_users:
#     - alice@example.com
#
#   # If `strip_email_domain` is set to `true`, the domain part of the username email address will be removed.
#   # This will transform `first-name.last-name@example.com` to the user `first-name.last-name`
#   # If `strip_email_domain` is set to `false` the domain part will NOT be removed resulting to the following
#   user: `first-name.last-name.example.com`
#
#   strip_email_domain: true

# Logtail configuration
# Logtail is Tailscales logging and auditing infrastructure, it allows the control panel
# to instruct tailscale nodes to log their activity to a remote server.
logtail:
  # Enable logtail for this headscales clients.
  # As there is currently no support for overriding the log server in headscale, this is
  # disabled by default. Enabling this will make your clients send logs to Tailscale Inc.
  enabled: false

# Enabling this option makes devices prefer a random port for WireGuard traffic over the
# default static port 41641. This option is intended as a workaround for some buggy
# firewall devices. See https://tailscale.com/kb/1181/firewalls/ for more information.
randomize_client_port: false

```

### Caddy部署

```yaml
# docker network create [OPTIONS] NETWORK
# docker network create --ipv6 caddy_net
version: '3.5'
services:
  caddy:
    # build image to add new module
    # image: caddy:latest
    build: 
      context: .
      dockerfile: Dockerfile
    container_name: caddy
    networks:
      - caddy_net
    volumes:
      - ../../docker-data/caddy:/data
      - ./config:/config
      - /etc/localtime:/etc/localtime:ro 
    ports:
      - 80:80
      - 443:443
    env_file:
      - ./dnspod.env
    entrypoint: /usr/bin/caddy run --adapter caddyfile --config /config/Caddyfile

networks:
  caddy_net:
    name: caddy_net
    external: true
```

由于我需要接入 `泛域名`，所以这里自己build了一个镜像，如果没有这个需要，则直接拉取最新的 `caddy:latest`即可

### Caddy Dockerfile

Caddy 是用Go写的，若是需要添加新功能必须得重新编译。如下Dockerfile 添加了`cloudflare`模块，让Caddy支持`泛域名`

```
# Reference: https://hub.docker.com/_/caddy #Adding custom Caddy modules
FROM caddy:2.6.4-builder AS builder

# package can be found in https://caddyserver.com/download
RUN xcaddy build \
    --with github.com/caddy-dns/cloudflare

FROM caddy:latest

COPY --from=builder /usr/bin/caddy /usr/bin/caddy
```

### Caddy配置

```yaml
# all supported dns: https://caddyserver.com/docs/modules/
*.abc.top {
    tls {
        dns cloudflare {env.CF_API_TOKEN}
    }
}

# how to config wildcard-certificate https://caddyserver.com/docs/caddyfile/patterns#wildcard-certificates
headscale.abc.top {
    # headscale 服务地址
    reverse_proxy http://headscale:8080

    # headscale-ui 地址，必须与上面的域名一致，为了防止CORS错误
    handle /web* {
        reverse_proxy http://headscale-ui
    }
}
```

## 客户端

- [Tailscale-客户端接入](https://icloudnative.io/posts/how-to-set-up-or-migrate-headscale/#tailscale-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%85%A5)

### 命令汇总

```bash
# 创建用户
docker-compose -f headscale.yaml exec headscale \
  headscale users create ppsteven
# 注册节点（也可以通过图形化页面配置）
docker-compose -f headscale.yaml exec headscale \
  headscale nodes register --user jacky --key nodekey:xxxxxx
# 查看节点连接状态（获取内网ip，是否在线等）
docker-compose -f headscale.yaml exec headscale \
  headscale nodes list
# linux 命令行连接（用以获取设备的登录识别码 nodekey:xxxxx，拿这个码就可以去服务端连接了）
tailscale up --login-server=http://abc.com/ --accept-routes=true --accept-dns=false
# 查看你的IP地址与到各大公共DERP服务器之间的延迟
tailscale netcheck
# 查看各客户端的连接状态，是直连还是中继一目了然
tailscale status
```



## 参考

- [搭建属于自己的Tailscale网络](https://maxng.cc/posts/headscale-ez-tutorial/)

- [Tailscale 基础教程：Headscale 的部署方法和使用教程](https://icloudnative.io/posts/how-to-set-up-or-migrate-headscale/#tailscale-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%85%A5)

- [Headscale 搭建 P2P 内网穿透_](https://mritd.com/2022/10/19/use-headscale-to-build-a-p2p-network/#3-3%E3%80%81%E8%AF%81%E4%B9%A6%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86)

- [【官方】Headscale配置反向代理](https://github.com/juanfont/headscale/blob/main/docs/reverse-proxy.md#caddy)